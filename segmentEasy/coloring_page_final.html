<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro SVG Coloring Page Generator</title>
    <!-- Fabric.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #252526;
            --bg-input: #3c3c3c;
            --accent: #007acc;
            --text: #cccccc;
            --text-light: #ffffff;
            --border: #444;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-dark);
            color: var(--text);
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            display: grid;
            grid-template-columns: 260px 1fr 220px;
            overflow: hidden;
        }

        /* Layout Columns */
        .sidebar {
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 10px;
            overflow-y: auto;
            z-index: 10;
        }

        .sidebar-right {
            border-right: none;
            border-left: 1px solid var(--border);
        }

        .main-area {
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Changed from auto to hidden to rely on CSS scaling */
            position: relative;
            padding: 20px;
        }

        /* Canvas Wrapper & Checkerboard */
        /* This container scales down to fit the screen */
        .canvas-container-outer {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        
        /* The actual wrapper Fabric uses */
        .canvas-wrapper {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-image:
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #fff;
            transform-origin: center center; /* Scale from center */
        }

        /* UI Elements */
        h3 {
            font-size: 14px;
            text-transform: uppercase;
            color: var(--text-light);
            margin: 15px 0 5px 0;
            border-bottom: 1px solid var(--border);
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
        }

        input[type="number"], input[type="text"], button, select {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: white;
            padding: 6px;
            box-sizing: border-box;
            border-radius: 3px;
            margin-bottom: 5px;
        }

        input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        button {
            background: var(--bg-input);
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover { background: #505050; }
        button.primary { background: var(--accent); color: white; border: none; }
        button.primary:hover { background: #0062a3; }
        button.danger { background: #a30000; }

        .tool-btn {
            text-align: left;
            padding: 8px;
            margin-bottom: 2px;
        }
        .tool-btn.active {
            background: var(--accent);
            color: white;
        }

        /* Layers Panel */
        .layer-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .layer-item {
            background: var(--bg-input);
            border-bottom: 1px solid var(--border);
            padding: 8px;
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        
        .layer-item.active {
            border-left: 3px solid var(--accent);
            background: #444;
        }

        .layer-name {
            flex-grow: 1;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-controls {
            display: flex;
            gap: 5px;
        }

        .icon-btn {
            background: none;
            border: none;
            color: #aaa;
            padding: 2px;
            font-size: 12px;
            width: auto;
        }
        .icon-btn:hover { color: white; background: none; }

    </style>
</head>
<body>

    <!-- LEFT SIDEBAR -->
    <div class="sidebar">
        <h3>Project</h3>
        <div class="control-group">
            <button class="primary" onclick="document.getElementById('fileInput').click()">Upload SVG</button>
            <input type="file" id="fileInput" accept=".svg" style="display: none">
        </div>

        <h3>Canvas Settings</h3>
        <div class="control-group">
            <label>Width (px)</label>
            <input type="number" id="canvasWidth" value="2550">
            <label>Height (px)</label>
            <input type="number" id="canvasHeight" value="3300">
            <label>DPI (Reference)</label>
            <input type="number" id="canvasDPI" value="300">
            <button onclick="updateCanvasSize()">Update Canvas</button>
        </div>

        <h3>SVG Stroke</h3>
        <div class="control-group">
            <label>Stroke Width (px)</label>
            <input type="number" id="svgStrokeWidth" value="9">
            <button onclick="updateSVGStyle()" style="margin-top:5px; font-size:11px;">Re-Apply Stroke</button>
        </div>

        <h3>Tools</h3>
        <div class="control-group">
            <button id="toolSelect" class="tool-btn" onclick="setTool('select')">Select / Edit</button>
            <button id="toolPen" class="tool-btn" onclick="setTool('pen')">Pen Tool (Bezier)</button>
            <div style="font-size: 10px; color: #888; margin-top: 5px; line-height: 1.4;">
                <strong>Pen Usage:</strong><br>
                ‚Ä¢ Click to add point<br>
                ‚Ä¢ Drag to curve<br>
                ‚Ä¢ Enter to finish<br>
                ‚Ä¢ Esc to cancel
            </div>
        </div>

        <h3>Clipping</h3>
        <div class="control-group">
            <label style="display:flex; align-items:center;">
                <input type="checkbox" id="clipCheck" onchange="toggleClipping()"> 
                Clip to SVG Layer
            </label>
        </div>

        <h3>Export</h3>
        <div class="control-group">
            <button class="primary" onclick="exportPNG()">Export Image (PNG)</button>
            <button onclick="exportSVGPaths()">Export Paths (SVG)</button>
        </div>
    </div>

    <!-- CENTER CANVAS -->
    <div class="main-area">
        <div class="canvas-container-outer" id="canvasContainerOuter">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="c"></canvas>
            </div>
        </div>
    </div>

    <!-- RIGHT SIDEBAR (LAYERS) -->
    <div class="sidebar sidebar-right">
        <h3>Layers</h3>
        <div style="margin-bottom: 10px; padding: 0 5px;">
            <button onclick="addDrawingLayer()">+ New Layer</button>
        </div>
        <ul id="layerList" class="layer-list">
            <!-- Layers injected by JS -->
        </ul>
    </div>

    <script>
        // --- STATE ---
        let canvas;
        let svgObject = null; // The background SVG
        let svgPrefix = "drawing"; // Captured from filename
        let layers = []; // Array of { id, name, type, fabricObj, visible }
        let activeLayerId = null;
        let isClipping = false;
        let currentMode = 'select'; // 'select' or 'pen'
        let penState = { points: [] };
        let canvasConfig = { width: 2550, height: 3300, dpi: 300 };
        let tempPath = null;
        let points = []; 
        let isDragging = false;
        let activeAnchor = null;

        // --- INITIALIZATION ---
        window.onload = function() {
            canvas = new fabric.Canvas('c', {
                width: canvasConfig.width,
                height: canvasConfig.height,
                backgroundColor: null, // Transparent
                preserveObjectStacking: true,
                selection: true
            });

            // Handle file upload
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            
            // Inputs listeners
            document.getElementById('svgStrokeWidth').addEventListener('change', updateSVGStyle);

            // Responsive Scaling Listener
            window.addEventListener('resize', fitCanvasToScreen);
            
            // Initial Layer
            initLayers();
            setTool('select');
            
            // Fabric events for Pen Tool
            canvas.on('mouse:down', onMouseDown);
            canvas.on('mouse:move', onMouseMove);
            canvas.on('mouse:up', onMouseUp);
            // Keyboard events
            document.addEventListener('keydown', onKeyDown);

            // Initial fit
            fitCanvasToScreen();
        };

        // --- DISPLAY SCALING (FIX FOR BIG CANVAS) ---
        function fitCanvasToScreen() {
            const outer = document.getElementById('canvasContainerOuter');
            const wrapper = document.getElementById('canvasWrapper');
            const margin = 40; // padding inside main area

            const availableWidth = outer.clientWidth - margin;
            const availableHeight = outer.clientHeight - margin;

            const scaleW = availableWidth / canvasConfig.width;
            const scaleH = availableHeight / canvasConfig.height;

            // Pick the smaller scale to fit entirely
            const scale = Math.min(scaleW, scaleH);

            // Apply CSS transform to the wrapper
            // We use transform so the internal coordinate system stays at 2550x3300
            wrapper.style.transform = `scale(${scale})`;
            wrapper.style.width = `${canvasConfig.width}px`;
            wrapper.style.height = `${canvasConfig.height}px`;
            
            // Center it manually via margins if needed, or flex handles it
            // Flex handles it mostly, but let's ensure size is explicit
        }

        function updateCanvasSize() {
            const w = parseInt(document.getElementById('canvasWidth').value);
            const h = parseInt(document.getElementById('canvasHeight').value);
            const dpi = parseInt(document.getElementById('canvasDPI').value);
            
            canvasConfig = { width: w, height: h, dpi: dpi };
            canvas.setDimensions({ width: w, height: h });
            
            // Rescale SVG if exists
            if (svgObject) {
                fitSvgToCanvas();
            }
            // Re-calc screen fit
            fitCanvasToScreen();
        }

        // --- SVG HANDLING ---
        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            svgPrefix = file.name.replace(/\.svg$/i, '');

            const reader = new FileReader();
            reader.onload = function(f) {
                const svgStr = f.target.result;
                fabric.loadSVGFromString(svgStr, function(objects, options) {
                    
                    // 1. Force styles on ALL sub-paths before grouping
                    // Many SVGs have colors on individual paths, which override group colors.
                    objects.forEach(obj => {
                        forceStyleOnObject(obj);
                    });

                    // 2. Create the Group
                    const obj = fabric.util.groupSVGElements(objects, options);
                    
                    if (svgObject) canvas.remove(svgObject);
                    svgObject = obj;
                    
                    // 3. Fit and Style
                    fitSvgToCanvas();
                    updateSVGStyle(); 
                    
                    canvas.add(svgObject);
                    svgObject.selectable = false;
                    svgObject.evented = false; 
                    canvas.sendToBack(svgObject);
                    
                    initLayers(); 
                });
            };
            reader.readAsText(file);
        }

        // Recursive function to force White Fill / Black Stroke on everything
        function forceStyleOnObject(obj) {
            // Apply to self
            obj.set({
                fill: '#FFFFFF',
                stroke: '#000000',
                strokeWidth: 1 // Base width, updated later
            });

            // If it's a group, recurse
            if (obj._objects && obj._objects.length) {
                obj._objects.forEach(child => forceStyleOnObject(child));
            } else if (obj.type === 'path') {
                // Ensure paths don't have "null" fill if they were transparent
                obj.set({ fill: '#FFFFFF' });
            }
        }

        function fitSvgToCanvas() {
            if (!svgObject) return;
            
            svgObject.scaleX = 1;
            svgObject.scaleY = 1;
            const bounds = svgObject.getBoundingRect();
            
            const scaleX = canvasConfig.width / bounds.width;
            const scaleY = canvasConfig.height / bounds.height;
            
            svgObject.set({
                scaleX: scaleX,
                scaleY: scaleY,
                originX: 'left',
                originY: 'top',
                left: 0,
                top: 0
            });
            svgObject.setCoords();
            canvas.requestRenderAll();
        }

        function updateSVGStyle() {
            if (!svgObject) return;
            const strokeWidth = parseInt(document.getElementById('svgStrokeWidth').value) || 9;
            
            // FIX for "SVG doesn't have fill/stroke":
            // We must apply the color to the Group, but also ensure sub-paths don't override it.
            // Since we already normalized sub-paths in handleFileUpload, we apply master style here.
            
            // 1. CLIPPING TECHNIQUE for "Inside Stroke"
            // We clone the object to use as its own clip mask.
            svgObject.clone(function(clone) {
                clone.set({
                    left: svgObject.left,
                    top: svgObject.top,
                    scaleX: svgObject.scaleX,
                    scaleY: svgObject.scaleY,
                    absolutePositioned: true
                });

                // Apply styles
                // We must traverse again if the group ignores property inheritance
                recursiveApplyStyle(svgObject, {
                    fill: '#FFFFFF',
                    stroke: '#000000',
                    strokeWidth: strokeWidth * 2, // Double width for inside effect
                    strokeLineCap: 'round',
                    strokeLineJoin: 'round'
                });

                // Apply clip to the main group
                svgObject.clipPath = clone;
                
                canvas.requestRenderAll();
            });
            
            if(isClipping) applyClippingMask();
        }

        function recursiveApplyStyle(obj, style) {
            obj.set(style);
            if (obj._objects && obj._objects.length) {
                obj._objects.forEach(child => recursiveApplyStyle(child, style));
            }
        }

        // --- PEN TOOL & LAYERS (Identical logic to previous, ensuring stability) ---
        
        function setTool(tool) {
            currentMode = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            if(tool === 'pen') document.getElementById('toolPen').classList.add('active');
            else document.getElementById('toolSelect').classList.add('active');

            if (tool === 'select') {
                canvas.selection = true;
                canvas.forEachObject(o => o.selectable = (o !== svgObject));
                finishPath(); 
            } else {
                canvas.selection = false;
                canvas.discardActiveObject();
                canvas.forEachObject(o => o.selectable = false);
                canvas.requestRenderAll();
            }
        }

        function onMouseDown(opt) {
            if (currentMode !== 'pen') return;
            const pointer = canvas.getPointer(opt.e);
            
            // Scale pointer adjustment not needed because Fabric handles CSS scaling automatically
            // IF we used CSS zoom. We used transform scale. Fabric's getPointer usually handles this 
            // BUT sometimes needs manual adjustment if transform is on wrapper. 
            // Fabric calculates offset based on canvas element client rect.
            
            const p = { x: pointer.x, y: pointer.y };
            
            if (points.length === 0) {
                points.push({ type: 'M', x: p.x, y: p.y });
            } else {
                points.push({ type: 'L', x: p.x, y: p.y });
            }
            activeAnchor = points.length - 1;
            isDragging = true;
            renderTempPath();
        }

        function onMouseMove(opt) {
            if (currentMode !== 'pen') return;
            if (!isDragging || points.length === 0) return;
            
            const pointer = canvas.getPointer(opt.e);
            const anchor = points[activeAnchor];
            
            // Convert last point to Curve (Quad)
            anchor.type = 'Q';
            anchor.x1 = pointer.x;
            anchor.y1 = pointer.y;

            renderTempPath();
        }

        function onMouseUp() {
            if (currentMode !== 'pen') return;
            isDragging = false;
        }

        function onKeyDown(e) {
            if (e.key === 'Enter') finishPath();
            if (e.key === 'Escape') {
                points = [];
                if (tempPath) canvas.remove(tempPath);
                tempPath = null;
                canvas.requestRenderAll();
            }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (currentMode === 'select') deleteActiveLayerContent();
            }
        }

        function renderTempPath() {
            if (tempPath) canvas.remove(tempPath);
            let d = "";
            points.forEach(p => {
                if (p.type === 'M') d += `M ${p.x} ${p.y} `;
                if (p.type === 'L') d += `L ${p.x} ${p.y} `;
                if (p.type === 'Q') d += `Q ${p.x1} ${p.y1} ${p.x} ${p.y} `;
            });

            tempPath = new fabric.Path(d, {
                stroke: 'black',
                strokeWidth: 2,
                fill: '',
                selectable: false,
                evented: false,
                strokeDashArray: [5, 5]
            });
            canvas.add(tempPath);
            canvas.requestRenderAll();
        }

        function finishPath() {
            if (points.length < 2) return;
            let d = "";
            points.forEach(p => {
                if (p.type === 'M') d += `M ${p.x} ${p.y} `;
                if (p.type === 'L') d += `L ${p.x} ${p.y} `;
                if (p.type === 'Q') d += `Q ${p.x1} ${p.y1} ${p.x} ${p.y} `;
            });

            const pathObj = new fabric.Path(d, {
                fill: '', 
                stroke: '#000000',
                strokeWidth: 9, 
                strokeLineCap: 'round',
                strokeLineJoin: 'round',
                strokeUniform: true 
            });

            const activeLayer = layers.find(l => l.id === activeLayerId);
            if (activeLayer && activeLayer.type === 'drawing') {
                pathObj.layerId = activeLayerId;
                if (isClipping) applyClipToObj(pathObj);
                canvas.add(pathObj);
                canvas.setActiveObject(pathObj);
            } else {
                alert("Please select a Drawing Layer first.");
            }

            points = [];
            if (tempPath) canvas.remove(tempPath);
            tempPath = null;
            canvas.requestRenderAll();
        }

        function initLayers() {
            layers = [];
            layers.push({ id: 'svg', name: 'SVG Background (Mask)', type: 'svg', visible: true });
            addDrawingLayer("Drawing Layer 1", false);
            renderLayerList();
            setActiveLayer(layers[1].id);
        }

        function addDrawingLayer(name, render = true) {
            const id = 'layer_' + new Date().getTime();
            const n = name || `Layer ${layers.length}`;
            layers.push({ id: id, name: n, type: 'drawing', visible: true });
            if (render) {
                renderLayerList();
                setActiveLayer(id);
            }
        }

        function deleteActiveLayerContent() {
            const active = canvas.getActiveObjects();
            if (active.length) {
                canvas.remove(...active);
                canvas.discardActiveObject();
                canvas.requestRenderAll();
            }
        }
        
        function deleteLayer(id) {
            if (id === 'svg') return; 
            const objects = canvas.getObjects().filter(o => o.layerId === id);
            canvas.remove(...objects);
            layers = layers.filter(l => l.id !== id);
            renderLayerList();
            if (activeLayerId === id) setActiveLayer('svg');
        }

        function toggleLayerVisibility(id) {
            const layer = layers.find(l => l.id === id);
            if (!layer) return;
            layer.visible = !layer.visible;
            if (id === 'svg') {
                if (svgObject) svgObject.visible = layer.visible;
            } else {
                canvas.getObjects().filter(o => o.layerId === id).forEach(o => o.visible = layer.visible);
            }
            canvas.requestRenderAll();
            renderLayerList();
        }

        function setActiveLayer(id) {
            activeLayerId = id;
            renderLayerList();
        }

        function renderLayerList() {
            const list = document.getElementById('layerList');
            list.innerHTML = '';
            [...layers].reverse().forEach(layer => {
                const li = document.createElement('li');
                li.className = `layer-item ${layer.id === activeLayerId ? 'active' : ''}`;
                li.onclick = () => setActiveLayer(layer.id);
                li.innerHTML = `
                    <button class="icon-btn" onclick="event.stopPropagation(); toggleLayerVisibility('${layer.id}')">
                        ${layer.visible ? 'üëÅ' : '‚óã'}
                    </button>
                    <span class="layer-name" style="margin-left: 8px;">${layer.name}</span>
                    ${layer.type !== 'svg' ? 
                        `<button class="icon-btn" onclick="event.stopPropagation(); deleteLayer('${layer.id}')">üóë</button>` 
                        : ''}
                `;
                list.appendChild(li);
            });
        }

        function toggleClipping() {
            isClipping = document.getElementById('clipCheck').checked;
            applyClippingMask();
        }

        function applyClippingMask() {
            if (!svgObject) return;
            const userObjects = canvas.getObjects().filter(o => o.layerId && o.layerId.startsWith('layer_'));
            userObjects.forEach(obj => {
                if (isClipping) applyClipToObj(obj);
                else obj.clipPath = null;
                obj.dirty = true;
            });
            canvas.requestRenderAll();
        }

        function applyClipToObj(obj) {
            svgObject.clone(function(clone) {
                clone.set({
                    left: svgObject.left,
                    top: svgObject.top,
                    scaleX: svgObject.scaleX,
                    scaleY: svgObject.scaleY,
                    absolutePositioned: true,
                    stroke: null, 
                    fill: 'black'
                });
                obj.clipPath = clone;
                canvas.requestRenderAll();
            });
        }

        function getTimestamp() {
            const d = new Date();
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}${month}${day}`;
        }

        function exportPNG() {
            canvas.discardActiveObject();
            canvas.requestRenderAll();
            const dataURL = canvas.toDataURL({ format: 'png', multiplier: 1, enableRetinaScaling: false });
            const link = document.createElement('a');
            const filename = `${svgPrefix}-${canvasConfig.width}x${canvasConfig.height}-${canvasConfig.dpi}dpi-${getTimestamp()}.png`;
            link.download = filename;
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportSVGPaths() {
            const userObjects = canvas.getObjects().filter(o => o.layerId && o.layerId.startsWith('layer_'));
            if (userObjects.length === 0) {
                alert("No drawn paths to export.");
                return;
            }
            let svgBody = '';
            userObjects.forEach(obj => svgBody += obj.toSVG());
            const svgHeader = `<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<svg xmlns="http://www.w3.org/2000/svg" width="${canvasConfig.width}" height="${canvasConfig.height}" viewBox="0 0 ${canvasConfig.width} ${canvasConfig.height}">`;
            const svgFooter = `</svg>`;
            const blob = new Blob([svgHeader + svgBody + svgFooter], {type: "image/svg+xml;charset=utf-8"});
            const link = document.createElement('a');
            const filename = `${svgPrefix}-paths-${canvasConfig.width}x${canvasConfig.height}-${getTimestamp()}.svg`;
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>
